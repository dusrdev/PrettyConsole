## Default abstractions (trim friendly)

```csharp
public static void Write(string? output);
public static void WriteLine(string? output);
```

## Generic abstraction

```csharp
public static void Write<T>(T item);
public static void WriteLine<T>(T item);
```

`T` must not be null.

There are overloads that allow the changing of the color as well with second parameter of type `ConsoleColor`, could be used conveniently by using the static `Colors` object that contains the default colors

**Colors** is a property that allows access to the **defaults**.
 
This is the recommended way to use colors because the package this way the output will be colored, but still uniform, and the default colors
are used when the `ConsoleColor` parameter is missing, thus you write less code to get the same result:

* Default
* Highlight
* Success
* Error
* Input

when used like this it will make the output seem much more uniform and will be easier to code.
if you want, you can override the defaults -> [like this](https://github.com/dusrdev/PrettyConsole/wiki/1.-Defaults#colors)

 ## Multi-color output

```csharp
public static void Write(params (string item, ConsoleColor color)[] elements);
public static void WriteLine(params (string item, ConsoleColor color)[] elements);
```

âš  There are overloads that use `object` instead of `string`, these overloads cause what is known as **boxing** and declared obsolete.
use the overloads above for the best performance.

Same as the options before you have a choice between using the default or any `System.Console` color.  
here you use a `Tuple` to provide each (part, ConsoleColor) to the output. This is very intuitive and much more readable when inspecting the code.  

Example:

```csharp
WriteLine(("The color ", Colors.Default), ("highlight ", Colors.Highlight), ("is written in ", Colors.Default), ("this ", Colors.Highlight), ("color.", Color.Default));
```

This will write everything in `Colors.Default` and "highlight" and "this" in `Colors.Highlight`.
