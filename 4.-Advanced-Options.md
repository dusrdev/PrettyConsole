## Selection

```csharp
public static string Selection(string title, IEnumerable<string> choices);
```

This option is used when you give a user a list of options and want him to select one.  
the `choices` will be displayed as an enumerated list, the user will select the option by number, and the choice in string will be returned.  

Example:

```csharp
string choice = Selection("Select the desired option:", new string[] { "one", "two", "three" });
```

Will display:

```
Select the desired option:

1. one
2. two
3. three
```

if the user selects `2`, than `choice == "two"`.

## Multi-selection

```csharp
public static List<string> MultiSelection(string title, IEnumerable<string> choices);
```

Multi-selection is similar to selection except it will allow the user to select multiple options by entering their corresponding numbers separated by spaces.  

* The order in which they are entered does not matter.

If the choices are the same as previous example, and the user enters `"1 3"` or `"3 1"`, than a list containing `{ "one", "three" }` will be returned.

## Tree menu

```csharp
public static (string option, string subOption) TreeMenu(string title, Dictionary<string, List<string>> menu);
```

This is a more complex option and should be used when dealing with nested options.  
you will need to create a dictionary in which every key is the option name, and a list of nested choices is it's value.  
the user will interact with this menu in a same matter as the previous options, by entered the number of option and number of sub option like this: "1 3"  
this will return the string of the main option, and string of the nested option.

## Indeterminate Progress-Bar

```csharp
public static async Task IndeterminateProgressBar<T>(Task<T> task, ConsoleColor color, string title bool displayElapsedTime, int updateRate = 50);
```

This will display a simple twirl style indeterminate progress bar for times when you have a long running operation but one which  
progress can't be quantified.  
You run the operation in a task and all you need is to pass the task, the progress bar will update itself according to the *updateRate* and stop when the task has completed, and return the task result, so you can just set the task and await the progressbar. You can also customize a title along-side the progress bar, color, and a timer which shows the elapsed time.

Example:

```csharp
static async Task<double> TimeConsumingTask() {
    await Task.Delay(2000);
    return Math.PI;
}

var task = TimeConsumingTask();
var result = await IndeterminateProgressBar(task, Colors.Primary, "working", true);
```

Here the task can be of any type (or void).
then await the result, if you await before calling the progress-bar, the progressbar will not show.

You could also do something like this if you code is not async:

```csharp
static double TimeConsumingTask() {
    var t = Task.Delay(2000);
    t.Wait();
    return Math.PI;
}

var task = new Task<double>(() => TimeConsumingTask());
var progress = IndeterminateProgressBar(task, Colors.Primary, "working", true);
progress.Wait();
var result = progress.Result;
```

## Regular Progress-Bar

```csharp
public static void UpdateProgressBar(int percent);
public static void UpdateProgressBar(int percent, ConsoleColor color);
public static void UpdateProgressBar(int percent, ConsoleColor foregound, ConsoleColor progress);
public static void UpdateProgressBar(ProgressBarDisplay display);
```

When you have a task going on that reports a progress, you can pass the progress with each report or change to update this progress bar.  
After it is finished, remember to break to a new line.  

* The overload that takes a `ProgressBarDisplay` allows more options and cleaner code, to keep performance optimal, `ProgressBarDisplay` is a `readonly ref struct` which means it is guaranteed to be kept out of the heap and allocated directly to the stack. 

Example:

```csharp
for (var i = 0; i <= 100; i++) {
    UpdateProgressBar(i);
    await Task.Delay(100);
}
NewLine();
```

### Important note

If the progress bar will be called too frequently either by your operation or something uncontrollable like when the progress bar is called to display info from an `event`. The progress bar might start rendering a new one before the old render is finished, causing artifacts.

There are a few ways of solving this issue.

If you can control the execution time manually, the easiest is to implement some sort of a timed delay like this:

```csharp
if (Stopwatch.GetElapsedTime(_previousUpdate) < TimeSpan.FromMilliseconds(500)) {
    return;
}
_previousUpdate = Stopwatch.GetTimestamp();
UpdateProgressBar(...)
```

If the progress bar is called from an `event`, combine the delay above with the attribute
`[MethodImpl(MethodImplOptions.Synchronized)]` above the `event`, this will make sure that no new threads are launched to execute the event, if one thread is already waiting in line. Otherwise, you might have 2 threads executing the event, which will try to render the progress bar in the same time.

To make sure the cursor itself doesn't interfere with rendering you can set `System.Console.CursorVisible = false` and return it to `true` once the progress bar is finished or no longer needed. This will not interfere with inputs or cancellation.

## Override Current Line

Sometimes you want to display a certain output that you want to override multiple times, example is maybe an antivirus, which wants to show which file it currently analyzing. Like a progress bar but that only displays a string.

Use with `OverrideCurrentLine(string output)`, an optional parameter for `ConsoleColor` is also available.

## Clear Next Lines

If you used a progress bar with a header for example, you would see that it takes 2 lines to render. And returns the start of those 2 lines after every render. But the lines remain with the old content. So if you wanted to print something that takes less than 2 lines after it is finished, parts of it will remain rendered on the terminal. That is where this comes in, Call this after the progress bar is finished, and all of its area will be cleared.

Use with `ClearNextLines(int lines)` 